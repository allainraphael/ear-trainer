<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Interactive EQ Ear Training</title>
<style>
body {
    font-family: sans-serif;
    background:#222;
    color:#fff;
    display:flex;
    justify-content:center;
    padding:20px;
}
#container {
    position:relative;
    width:90%;
    max-width:1000px;
    display:flex;
    flex-direction:column;
    align-items:center;
}
canvas {
    width:100%;
    height:400px;
    background:#111;
    border-radius:10px;
}
.controls {
    margin-top:10px;
    display:flex;
    gap:5px;
    justify-content:center;
    z-index:1;
}
input[type=range]{width:100px;}
</style>
</head>
<body>
<div id="container">
    <canvas id="spectrum"></canvas>
    <div class="controls">
        <input type="file" id="audioFile" accept="audio/*">
        <button id="playBtn">‚ñ∂Ô∏è Play</button>
        <button id="pauseBtn">‚è∏Ô∏è Pause</button>
        <button id="stopBtn">‚èπÔ∏è Stop</button>
        <button id="loopBtn">üîÅ Loop</button>
        <input type="range" id="volumeSlider" min="0" max="1" step="0.01" value="0.7">
    </div>
</div>

<script>
class InteractiveEQ {
    constructor() {
        this.audioCtx = null;
        this.buffer = null;
        this.source = null;
        this.gainNode = null;
        this.analyser = null;
        this.activeBands = new Set();

        this.canvas = document.getElementById('spectrum');
        this.ctx = this.canvas.getContext('2d');

        this.bands = {
            'sub-bass': {low:20, high:60, color:'rgba(255,107,107,0.3)'},
            'bass': {low:60, high:250, color:'rgba(255,165,0,0.3)'},
            'low-mid': {low:250, high:500, color:'rgba(255,255,0,0.3)'},
            'mid': {low:500, high:2000, color:'rgba(0,255,0,0.3)'},
            'high-mid': {low:2000, high:4000, color:'rgba(0,255,255,0.3)'},
            'treble': {low:4000, high:8000, color:'rgba(0,128,255,0.3)'},
            'high-treble': {low:8000, high:20000, color:'rgba(128,0,255,0.3)'}
        };

        this.initEvents();
        this.resizeCanvas();
        window.addEventListener('resize',()=>this.resizeCanvas());
        this.drawLoop();
    }

    initEvents() {
        document.getElementById('audioFile').addEventListener('change', e=>this.loadFile(e));
        document.getElementById('playBtn').addEventListener('click', ()=>this.play());
        document.getElementById('pauseBtn').addEventListener('click', ()=>this.pause());
        document.getElementById('stopBtn').addEventListener('click', ()=>this.stop());
        document.getElementById('loopBtn').addEventListener('click', ()=>this.toggleLoop());
        document.getElementById('volumeSlider').addEventListener('input', e=>this.setVolume(e.target.value));

        this.canvas.addEventListener('click', e=>{
            const rect = this.canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const band = this.getBandByX(x);
            if(band){
                if(this.activeBands.has(band)) this.activeBands.delete(band);
                else this.activeBands.add(band);
                this.play();
            }
        });
    }

    resizeCanvas() {
        this.canvas.width = this.canvas.offsetWidth*window.devicePixelRatio;
        this.canvas.height = this.canvas.offsetHeight*window.devicePixelRatio;
        this.ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
    }

    async loadFile(event){
        const file = event.target.files[0];
        if(!file) return;
        if(!this.audioCtx) this.audioCtx = new (window.AudioContext||window.webkitAudioContext)();
        const arrayBuffer = await file.arrayBuffer();
        this.buffer = await this.audioCtx.decodeAudioData(arrayBuffer);
        this.setupAnalyser();
    }

    setupAnalyser(){
        this.analyser = this.audioCtx.createAnalyser();
        this.analyser.fftSize = 2048;
        this.gainNode = this.audioCtx.createGain();
        this.setVolume(document.getElementById('volumeSlider').value);
    }

    play(){
        if(!this.buffer) return;
        this.stop();
        this.source = this.audioCtx.createBufferSource();
        this.source.buffer = this.buffer;
        this.source.loop = this.isLooping || false;

        let node = this.source;
        if(this.activeBands.size>0){
            const bandNodes = [];
            this.activeBands.forEach(b=>{
                bandNodes.push(this.createBandpass(this.bands[b]));
            });
            if(bandNodes.length===1) node = bandNodes[0];
            else {
                const merger = this.audioCtx.createChannelMerger(bandNodes.length);
                bandNodes.forEach((b,i)=>b.connect(merger,i,0));
                node.connect(merger);
                node = merger;
            }
        }

        node.connect(this.gainNode).connect(this.analyser).connect(this.audioCtx.destination);
        this.source.start();
    }

    pause(){ this.stop(); }
    stop(){ if(this.source){ this.source.stop(); this.source=null; } }

    toggleLoop(){ 
        this.isLooping = !this.isLooping;
        if(this.source) this.source.loop = this.isLooping;
        document.getElementById('loopBtn').textContent = this.isLooping?'üîÅ Loop ON':'üîÅ Loop';
    }

    setVolume(val){ this.gainNode?this.gainNode.gain.value=val:null; }

    createBandpass(band){
        const hp = this.audioCtx.createBiquadFilter();
        hp.type='highpass'; hp.frequency.value=band.low; hp.Q.value=5;
        const lp = this.audioCtx.createBiquadFilter();
        lp.type='lowpass'; lp.frequency.value=band.high; lp.Q.value=5;
        hp.connect(lp);
        return hp;
    }

    getBandByX(x){
        const width=this.canvas.offsetWidth;
        for(const key in this.bands){
            const b=this.bands[key];
            const x1=(Math.log10(b.low/20)/Math.log10(20000/20))*width;
            const x2=(Math.log10(b.high/20)/Math.log10(20000/20))*width;
            if(x>=x1 && x<=x2) return key;
        }
        return null;
    }

    drawLoop(){
        const draw=()=>{
            const width=this.canvas.offsetWidth;
            const height=this.canvas.offsetHeight;
            this.ctx.clearRect(0,0,width,height);

            if(this.analyser){
                const bufferLength=this.analyser.frequencyBinCount;
                const dataArray=new Uint8Array(bufferLength);
                this.analyser.getByteFrequencyData(dataArray);

                this.ctx.beginPath();
                this.ctx.strokeStyle='#4facfe';
                this.ctx.lineWidth=2;

                const nyquist=this.audioCtx.sampleRate/2;
                for(let i=0;i<bufferLength;i++){
                    const freq=i*nyquist/bufferLength;
                    if(freq<20 || freq>20000) continue;
                    const x=(Math.log10(freq/20)/Math.log10(20000/20))*width;
                    const db=dataArray[i]/255;
                    const y=height-(db*height);
                    if(i===0) this.ctx.moveTo(x,y);
                    else this.ctx.lineTo(x,y);
                }
                this.ctx.stroke();
            }

            // Dessin des bandes
            for(const key in this.bands){
                const b=this.bands[key];
                const x1=(Math.log10(b.low/20)/Math.log10(20000/20))*width;
                const x2=(Math.log10(b.high/20)/Math.log10(20000/20))*width;
                this.ctx.fillStyle=this.activeBands.has(key)?b.color:'rgba(255,255,255,0.05)';
                this.ctx.fillRect(x1,0,x2-x1,height);
            }

            this.drawAxes(width,height);
            requestAnimationFrame(draw);
        };
        draw();
    }

    drawAxes(width,height){
        this.ctx.strokeStyle='rgba(255,255,255,0.3)';
        this.ctx.lineWidth=1;
        this.ctx.fillStyle='#fff';
        this.ctx.font='12px sans-serif';
        this.ctx.textAlign='center';
        this.ctx.textBaseline='top';

        // Axe X (fr√©quences)
        const freqs=[20,50,100,200,500,1000,2000,5000,10000,20000];
        freqs.forEach(f=>{
            const x=(Math.log10(f/20)/Math.log10(20000/20))*width;
            this.ctx.beginPath();
            this.ctx.moveTo(x,height);
            this.ctx.lineTo(x,height-5);
            this.ctx.stroke();
            this.ctx.fillText(f>=1000?`${f/1000}k`:`${f}`,x,height-20);
        });

        // Axe Y (dB)
        this.ctx.textAlign='right';
        this.ctx.textBaseline='middle';
        const dbs=[0.0,0.25,0.5,0.75,1.0];
        dbs.forEach(db=>{
            const y=height-db*height;
            this.ctx.beginPath();
            this.ctx.moveTo(0,y);
            this.ctx.lineTo(width,y);
            this.ctx.stroke();
            this.ctx.fillText(`${Math.round(db*100)}%`, width-2, y);
        });
    }
}

new InteractiveEQ();
</script>
</body>
</html>
